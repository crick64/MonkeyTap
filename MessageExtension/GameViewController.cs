using System;
using System.Timers;
using Messages;
using UIKit;

namespace MessageExtension
{
	public partial class GameViewController : MSMessagesAppViewController
	{
		Timer gameTimer = new Timer();
		Boolean gameInProgress = false;
		int score = 0;
		int time = 50000; // Game time is 5 seconds

		protected GameViewController(IntPtr handle) : base(handle)
		{
			// Note: this .ctor should not contain any initialization logic.
		}

		public override void DidReceiveMemoryWarning()
		{
			// Releases the view if it doesn't have a superview.
			base.DidReceiveMemoryWarning();

			// Release any cached data, images, etc that aren't in use.
		}

		public override void ViewDidLoad()
		{
			base.ViewDidLoad();

			// As we are using a UIImageView, we need to detect taps with a UITapGestureRecognizer
			UITapGestureRecognizer tapGesture = new UITapGestureRecognizer((obj) =>
			{
				if (!gameInProgress)
				{
					// Reset the score before we start the game
					score = 0;
					InvokeOnMainThread(() =>
					{
						// Updating the UI, so we need to invoke on the main thread
						ScoreLabel.Text = "Score: 0";
					});
					// Reset the timer
					time = 5000;
					// Fire the timer every 100ms (this will provide us with the countdown)
					gameTimer.Interval = 100;
					// Start the timer and mark the game as in progress
					gameTimer.Start();
					gameInProgress = true;
				}
				else
				{
					// If the game is already in progress, increase the score
					score++;
					InvokeOnMainThread(() =>
					{
						ScoreLabel.Text = string.Format("Score: {0}", score);
					});
				}
			});
			Monkey.AddGestureRecognizer(tapGesture);

			gameTimer.Elapsed += (sender, e) =>
			{
				// This is triggered every 100ms (as previously set up)
				// so we need to deduct 100 from the time remaining
				time = time - 100;
				InvokeOnMainThread(() =>
				{
					// Update the time label with the time remaining
					TimerLabel.Text = string.Format("Time: {0:F1}s", (float)time / 1000);
				});

				if (time.Equals(0))
				{
					// Once we run out of time, stop the timer
					gameTimer.Stop();
					gameInProgress = false;
					InvokeOnMainThread(() =>
					{
						ScoreViewController scoreVC = Storyboard.InstantiateViewController("ScoreVC") as ScoreViewController;
						// Pass the score and ActiveConversation to the next ViewController
						scoreVC.finalScore = score;
						scoreVC.conversation = ActiveConversation;
						ShowViewController(scoreVC, this);

						// Reset the labels
						ScoreLabel.Text = "Tap monkey to begin!";
						TimerLabel.Text = "Time: 0.0s";
					});
				}
			};
		}

		public override void DidBecomeActive(MSConversation conversation)
		{
			base.DidBecomeActive(conversation);

			// Called when the extension is about to move from the inactive to active state.
			// This will happen when the extension is about to present UI.

			// Use this method to configure the extension and restore previously stored state.
		}

		public override void WillResignActive(MSConversation conversation)
		{
			base.WillResignActive(conversation);

			// Called when the extension is about to move from the active to inactive state.
			// This will happen when the user dissmises the extension, changes to a different
			// conversation or quits Messages.

			// Use this method to release shared resources, save user data, invalidate timers,
			// and store enough state information to restore your extension to its current state
			// in case it is terminated later.
		}

		public override void DidReceiveMessage(MSMessage message, MSConversation conversation)
		{
			base.DidReceiveMessage(message, conversation);

			// Called when a message arrives that was generated by another instance of this
			// extension on a remote device.

			// Use this method to trigger UI updates in response to the message.
		}

		public override void DidStartSendingMessage(MSMessage message, MSConversation conversation)
		{
			base.DidStartSendingMessage(message, conversation);

			// Called when the user taps the send button.
		}

		public override void DidCancelSendingMessage(MSMessage message, MSConversation conversation)
		{
			base.DidCancelSendingMessage(message, conversation);

			// Called when the user deletes the message without sending it.

			// Use this to clean up state related to the deleted message.
		}

		public override void WillTransition(MSMessagesAppPresentationStyle presentationStyle)
		{
			base.WillTransition(presentationStyle);

			// Called before the extension transitions to a new presentation style.

			// Use this method to prepare for the change in presentation style.
		}

		public override void DidTransition(MSMessagesAppPresentationStyle presentationStyle)
		{
			base.DidTransition(presentationStyle);

			// Called after the extension transitions to a new presentation style.

			// Use this method to finalize any behaviors associated with the change in presentation style.
		}
	}
}
